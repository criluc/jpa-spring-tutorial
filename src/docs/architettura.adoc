= Architettura di una applicazione basata su JPA
Marco Andreini <marco.andreini@besmartbeopen.it>
2016-02-20
:source-highlighter: highlightjs
:backend: revealjs
:revealjs_theme: night
:revealjs_slideNumber: true
:sourcedir: ../main/java

== DAO

[%step]
* Domain Access Object sono oggetti utili ad astrarre e separare due
sottosistemi diversi
* tipicamente in ambiente JEE separano le interazioni con la persistenza
dalla logica di funzionamento
* si possono testare meglio le logiche di funzionamento sostituendo i DAO reali
con degli ausili ad-hoc

== DTO

[%step]
* Il Domain Transfer Object è un _Design Pattern_ usato per trasferire dati tra
sottosistemi di un'applicazione
* tipicamente non hanno alcuna logica di funzionamento, sono solo contenitori
di dati
* quindi non richiedono test
* usati anche nella serializzazione per incapsulare dati anche provenienti
da bean diversi.

== Injection

?

== Controller

* In alcuni framework Web è presente il concetto di "controller" - simile a
quello espresso nel _Design Pattern_ *MVC*
* si occupa di uno o più richieste web per oggetti speicifi

== Data Binding

?

== Validazione

* C'è l'ottima la specifica *Bean Validation* (JSR 303)
* Si utilizzano le annotazioni sui campi dei _bean_ per indicare la tipologia di validazione
* È indipendente dal framework e dall'application server
* I validatori si possono estendere e personalizzare

== javax.validation

Ecco un primo esempio di validatori:

[source,java]
----
class BlogEntry {

    @NotNull
    String title;

    @NotNull
    String author;

    @NotNull
    Date date;
}
----


== Vincoli

|===
|@Digits |Il valore deve essere un numero in un certo range
|@Max |Il valore deve essere un intero minore o uguale al numero indicato in `value`
|@Min |Il valore deve essere un intero maggiore o uguale al numero indicato in `value`
|@Size |La lunghezza del valore deve corrispondere ai limiti `min` e `max` indicati
|===

== Altri vincoli

|===
|@NotNull |Il valore deve essere diverso da `null`
|@Null |Il valore essere `null`
|@Future |Il valore deve essere una data nel futuro
|@Past |Il valore deve essere una data nel passato
|===

== Altri vincoli^(2)^

|===
|@AssertTrue |il valore deve essere `true`
|@AssertFalse |Il valore deve essere `false`
|@Pattern |Il valore deve corrispondere alla _regular expression_ indicata in `regexp`
|===


== Cosa validare?
Questo tipo di vincoli è inseribile sui metodi, sui campi, sui parametri e
sui costruttori
[source,java]
----
class Expirer {

  public Expirer(@Min(10) intt days, @Future @NotNull Date expire) { ... }

  @AssertTrue
  public boolean isValid() { ... }
}
----

== Validazione esplicita

Ottenuto il validatore si può validare un bean direttamente:
[source,java]
----
ValidationFactory factory = Validation.buildDefaultValidationFactory();
Validator validator = factory.getValidator();
Set<ConstraintViolation> violations = validator.validate(myBlogEntry);
----
Il risultato è l'elenco delle violazioni della `myBlogEntry`.

== Validatore dal framework

Si può tipicamente ottenere via _injection_ dal framework:
[source,java]
----
@Resource
Validator validator;
----

== Validazione e JPA

Utilizzando JPA si possono validare i campi delle entity
[source,java]
----
class Person extends BaseEntity {
  @NotNull     // obbligatorio
  @Size(min=2) // i nomi sono minimo di 2 caratteri
  @Column(nullable=false)
  private String firstname;

  @NotNull     // obblligatorio
  @Size(min=2) // i cognomi sono minimo di 2 caratteri
  @Column(nullable=false)
  private String lastname;

  //...
}
----
In JPA tipicamente prima di persistere l'oggetto, verrà applicata la validazione.

