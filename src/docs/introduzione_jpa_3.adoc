= Introduzione a JPA^(3)^
Cristian Lucchesi <cristian.lucchesi@gmail.com>
2016-02-23
:source-highlighter: highlightjs
:backend: revealjs
:revealjs_theme: night
:revealjs_slideNumber: true
:sourcedir: ../main/java

== Relazioni e loro caratteristiche

* gli oggetti possono contenere uno o più riferimenti ad altri oggetti
** questi riferimenti prendono il nome di *relazioni*
* le relazioni hanno diverse caratteristiche
** la prima è la *direzionalità*, una relazione potrà essere:
*** unidirezionale se un oggetto fa riferimento ad un altro ma non avviene il contrario
*** bidirezionale se il riferimento tra gli oggetti è reciproco

== Relazioni bidirezionali
[source,java]
----
@Entity
public class Person {
  private Account account;
}
@Entity
public class Account {
  // Possessore
  private Person owner;
}
----

La Person ha una relazione con Account e viceversa.

== Relazioni unidirezionali

[source,java]
----
@Entity
public class Person {
  //... Altre proprietà
  private Province bornIn;
}
@Entity
public class Province {
  private String name;
}
----

Person ha una relazione con Province ma non viceversa.

== Relazioni e opzionalità

** altra caratteristica delle relazioni è l'opzionalità:
*** non è detto che la relazione debba esistere necessariamente.
*** Se non è obbligatoria, la relazione si dice opzionale.

== Relazioni e molteplicità^(3)^

* molteplicità della relazione
* la relazione può sussistere verso uno o più oggetti, in entrambe le direzioni
* si identificano pertanto tre tipi di relazioni
** uno a uno 
** uno a molti
** molti a molti

JPA permette di gestire le relazioni e di risparmiarci di scrivere molto codice

== Relazione uno a uno unidirezionale

* si utilizza l’annotazione *@OneToOne*

[source,java]
----
@Entity @Table(name="persons")
public class Person {
  @OneToOne
  private Account account;
}
@Entity @Table(name="accounts")
public class Account {
  // Non c'è il campo Person
}
----

* nelle relazioni unidirezionali l'annotazione è solo nell’entità che possiede il riferimento (_owning side_)
* la tabella _persons_ avrà una colonna con la chiave esterna che si riferisce alla tabella _accounts_.

== Relazione uno a uno bidirezionale

[source,java]
----
@Entity @Table(name="persons")
public class Person {
  @OneToOne
  private Account account;
}
@Entity @Table(name="accounts")
public class Account {
  @OneToOne(mappedBy="account")
  private Person person;
}
----

* l'annotazione @OneToOne è su entrambe le entità (_owning side_ e _inverse side_)
* l'attributo *mappedBy* specifica il *nome* della proprietà java utilizzata nella @OneToOne che è _owning side_

== L'importanza dell'owning side

* il Persistence Runtime JPA (es. Hibernate) effettua aggiornamenti della relazione sul db solo quando si cambia l'owning side
[source,java]
----
@Entity @Table(name="persons")
public class Person {
  @OneToOne
  private Account account;
}
@Entity @Table(name="accounts")
public class Account {
  @OneToOne(mappedBy="account")
  private Person person;
}
...
Person p = entityManager.getReference(Person.class, 1L);
account.setPerson(p); // Non viene modificato il db

Account a = entityManager.getReference(Account.class, 1L);
person.setAccount(a); // viene aggiornato il db
----

== Caricamento delle relazioni

[source,java]
.Esempio di find
----
Person p = entityManager.find(Person.class, 1L);
----

[source,sql]
.query sql
----
select
    personwith0_.id as id1_3_1_,
    personwith0_.account_id as account_4_3_1_,
    personwith0_.name as name2_3_1_,
    personwith0_.surname as surname3_3_1_,
    account1_.id as id1_2_0_,
    account1_.username as username2_2_0_ 
from
    persons personwith0_ 
left outer join
    accounts account1_ 
       on personwith0_.account_id=account1_.id 
where
    personwith0_.account_id=1
----

Quando si carica un oggetto tramite l'EntityManager questo si occupa di caricare gli oggetti
collegati con le opportune join.

== Annotazione @JoinColumn

* @JoinColumn permette di personalizzare la relazione:
** *name*: (String default il nome della variabile)
*** cambia il nome della colonna sul db
** *insertable*: (boolean default true) 
*** se false la colonna viene omessa nella insert
** *updatable*: (boolean default true) 
*** se false la colonna viene omessa nella update

== Annotazione @JoinColumn^(2)^

* @JoinColumn permette di personalizzare la relazione:
** *nullable* (boolean default true)
*** utilizzata per determinare il tipo di JOIN eseguita da jpa (INNER vs LEFT)
** columnDefinition (String default "")
*** frammento di SQL da utilizzare per la DDL della colonna

== Annotazione @JoinColumn^(3)^

[source,java]
----
@Entity @Table(name="persons")
public class Person {
  @OneToOne
  @JoinColumn(name="account_id", updatable = false)
  private Account account;
}
----

* viene indicato il nome della colonna da utilizzare per le join e che il campo non è aggiornabile

== Relazioni uno a molti

* un'entità può essere associata a più di un oggetto dello stesso tipo
* la relazione viene detta di  tipo uno a molti.
* analogamente alle relazioni uno ad uno può essere uni o bidirezionale

In questo caso le annotazioni utilizzate sono:

* *javax.persistence.OneToMany*
* *javax.persistence.ManyToOne*

== Relazioni uno a molti^(2)^

[source,java]
----
@Entity @Table(name = "persons")
public class Person {
  @OneToMany(mappedBy = "owner")
  private List<Car> cars = new ArrayList();
}
@Entity @Table(name = "cars")
public class Car {
  @ManyToOne
  private Person owner;
}
----

* una persona ha molte macchine @OneToMany
* molte macchine hanno lo stesso (uno) proprietario @ManyToOne

== Relazioni uno a molti^(3)^

[source,java]
----
@Entity @Table(name = "orders")
public class Order {
  @Size(min = 1)
  @OneToMany(mappedBy = "order")
  private List<LineItem> lineItems = new ArrayList<>();
}
@Entity @Table(name = "order_line_items")
public class LineItem {
  @NotNull
  @ManyToOne(optional = false)
  private Order order;
}
----

* un ordine ha molte righe di dettaglio (almeno una)
* più righe di dettaglio appartengono allo stesso ordine
* una riga di dettaglio deve appartenere ad un ordine

== Utilizzo delle relazioni

[source,java]
.Esempio Java
----
Order order = entityManager.find(Order.class, 1L);
System.out.println("Ordine " + order);
for (LineItem lineItem : order.getLineItems()) {
  System.out.println(
    String.format("Riga %s. %s: %s euro",
    lineItem.getId(), lineItem.getDescription(),lineItem.getAmount()));
}
----

[source,sql]
.query sql
----
select order0_.id as id1_4_0_ from orders order0_ where order0_.id=1

select lineitems0_.order_id as order_id4_4_0_, lineitems0_.id as id1_1_0_,
  lineitems0_.id as id1_1_1_, lineitems0_.amount as amount2_1_1_,
  lineitems0_.description as descript3_1_1_,
  lineitems0_.order_id as order_id4_1_1_
from LineItem lineitems0_ where lineitems0_.order_id=1
----

* non c'è bisogno di preoccuparsi delle join... ci pensa JPA

== Relazioni uno a molti e owning side

* il possessore della relazione _owning side_ è sempre con @ManyToMany
* l'_inverse side_ è sempre con @OneToMany che è quella con l'attributo mappedBy
* il JPA Engine tiene traccia dei cambiamenti solo sull'owning side
** (come avviene per le relazioni @OneToOne)

[source,java]
----
Order order = entityManager.find(Order.class, 1L);
order.getLineItems().add(lineItem); // Non viene modificato il db

LineItem li = entityManager.find(LineItem.class, 1L);
li.setOrder(order); // viene aggiornato il db
----

== @NamedQuery

* Si possono definire query statiche con nome
** Raccomandate perché le query usufruiscono del sistema di *cache*
[source,java]
----
@NamedQuery(name="ordered",  query="SELECT e FROM BlogEntry e ORDER BY e.date ASC")
public class BlogEntry {
...
----

[source,java]
----
public List<BlogEntry> allEntriesOrdered() {
    return entityManager.createNamedQuery("ordered", BlogEntry.class).getResultList();
}
----

== Criteria API

* sono una alternativa in JPA 2.x per a JPQL
* le query sono dinamiche
* si compongono a partire da oggetti Java standard
** le query sono create in modo typesafe
* il `CriteriaBuidler` si ottiene utilizzando il metodo
`EntityManager::getCriteriaBuilder`

== Esempio di query con Criteria API

[source,java]
----
CriteriaBuilder builder = entityManager.getCriteriaBuilder();
CriteriaQuery<BlogEntry> criteriaQuery = builder.createQuery(BlogEntry.class);
Root<BlogEntry> be = criteriaQuery.from(BlogEntry.class);
ParameterExpression<String> title = builder.parameter(String.Class);
criteriaQuery.select(be).where(builder.equals(be.get("title"), title);

TypedQuery<BlogEntry> typedQuery = entityManager.createQuery(criteriaQuery);
typedQuery.setParameter(parameter, "il mio titolo");
typedQuery.getSingleResult(); // recupera il blogentry con "il mio titolo"
----

== Implementazioni JPA

Esistono varie implementazioni JPA che tipicamente sono utilizzati all'interno
di application server:

* Hibernate, in JBoss/RedHat
* EclipseLink, Oracle
* OpenJPA
...
