= Introduzione a JPA
Marco Andreini <marco.andreini@gmail.com>
2016-02-18
:source-highlighter: highlightjs
:backend: revealjs
:revealjs_theme: night
:revealjs_slideNumber: true

== Architettura multi strato

Per creare applicazioni - anche complesse - si può utilizzare una architettura
multi-strato (_n-tier_).

Ciascuno strato:

 - si occupa di un insieme di funzionalità logicamente separato;
 - comunica con il precedente e il successivo;
 - è sviluppato separatamente e indipendentemente dagli altri.


== Architettura a tre livelli
Le applicazioni web sono spesso strutturate su *three-tier architecture*:

1. livello di presentazione, con la quale si interagisce direttamente con l'utente
2. livello applicativo (_businness logic_), si occupa della logica di funzionamento
3. livello dati, si occupa dell'immagazzinamento dei dati su database

== Object Relational Mapping
* L'ORM si occupa di automatizzare il processo di trasformazione dei dati tra
gli oggetti (istanze di classi) e i database.
* Perché è utile?

** semplifica enormemente il lavoro di interfacciamento al database;
** evita di dover scrivere le procedure di trasformazione a mano;
** ci vogliamo concentrare sulla _logica di funzionamento_ e non sulla
 struttura relazionale del database.

== ORM: altri benefici

- Permette una eventuale sincronizzazione automatica degli oggetti su database
- È piuttosto indipendente dal tipo di database
- Astrazione sui metodi di interrogazione
- Prestazioni: utilizzando meccanismi di cache semi-automatici

== Java Persistence API

JPA è una specifica java (_JSR_) per *accedere*, *memorizzare* e *gestire* dati tra
oggetti Java specifici e database relazionali.

È considerato come l'_ORM_ standard per rendere i dati persistenti in ambiente Java.

  È stato inizialmente definito nella specifica EJB3.0.

== Una entity
[source,java]
----
@Entity // genererà una TABLE di nome blog_entry
public class BlogEntry {

  @Id @GeneratedValue // genera una INT PRIMARY KEY autoincrementale di nome id
  private Integer id;

  @Column(nullable=false) // genererà un campo title di tipo VARCHAR NOT NULL
  private String title;

  private String summary; // semplici VARCHAR

  private String body;

  @Temporal
  private Date date;
}
----

== JPA e POJO
Si utilizzano oggetti di tipo POJO (Plain Old Java Object) e
la persistenza riguarda:

- il salvataggio dei dati
- la loro consultazione
- la loro gestione (aggiornamento, cancellazione,...)

== Hibernate come JPA
Hibernate è ORM che implementa la specifica JPA.

- Esistono diverse specifiche JPA (1.0, 2.0, 2.1…)
- Queste specifiche sono implementate in Hibernate in varie versioni.
- Noi utilizzeremo come riferimento la specifica JPA 2.0, che è implementata
  in Hibernate a partire dalla 4.0.

== Persistenza

Con Persistent Data ci si riferisce a dati permanenti in una applicazione

- i dati sono resi permanente salvandoli in uno storage come ad esempio un
  Database, un Filesystem o una memoria flash
- i dati sono mantenuti anche dopo i riavvii

== Annotazioni JPA

Le caratteristiche degli oggetti coinvolti - prevalentemente entity - sono
definite da annotazioni specifiche.

In precedenza si utilizzavano metadati inseriti appositi file XML, separati
dal codice Java.

 Gli XML hibernate per esempio ancora si trovano su software obsoleti.

== @Entity
Le entity in JPA sono gli oggetti persistenti

per esempio i dati degli articoli di un blog possono essere riassunti una
apposita entity:
[source,java]
----
include::src/main/java/it/besmartbeopen/model/BlogEntry.java[lines=12..28]
----

== Annotazioni JPA^2^

Le annotazioni come `@Entity`, `@Id` … sono utilizzate in Java sui vari elementi
coinvolti nella persistenza per indicare quale comportamento deve avere il JPA

Con JPA qui si intende il framework che implementa la specifica JPA (ad esempio _Hibernate_).

== @Id
Con `@Id` occorre annotare il campo che identifica la chiave primaria:

- Di solito è di tipo numerico o di tipo stringa
- Ci deve essere un solo campo annotato con `@Id` per entity.
- Le entity sono confrontate tramite il metodo equals
- In questo occorre utilizzare il campo annotato con `@Id`


== Chiavi primarie

- Se necessario è possibile utilizzare chiavi composte – ma è da evitare per rendere più chiaro il codice.

- Si può indicare una strategia per la generazione automatica dei valori delle chiavi primarie con:
[source,java]
----
include::src/main/java/it/besmartbeopen/model/BlogEntry.java[lines=13..15]
----
